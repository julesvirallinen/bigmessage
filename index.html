<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>JulesMessage</title>
    <style>
      body {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        height: 100vh;
        overflow: hidden;
        margin: 0;
        background-color: #f0f0f0;
        font-family: Arial, sans-serif;
      }
      #displayText {
        text-align: center;
        word-wrap: break-word;
        overflow-wrap: break-word;
        width: 100%;
        height: 100vh;
        font-family: HeavyData Nerd Font, monospace;
      }
      #inputContainer {
        display: flex;

        flex-direction: column;
        align-items: center;
      }
      textarea {
        font-size: 2rem;
        line-height: 3rem;
        padding: 0;
        padding: 20px;
        width: 500px;
        height: 200px;
        margin-bottom: 10px;
        resize: none;
        background-color: #f0f0f0;
        border: 1px solid #ccc;
        border-radius: 4px;
        text-align: center;
        display: flex;
        align-items: center;
        justify-content: center;
        word-wrap: break-word;
        font-family: inherit;
        padding-left: 10px;
        padding-right: 10px;
      }
      button {
        font-size: 1.5rem;
        padding: 10px 20px;
        cursor: pointer;
      }
      #styleOptions {
        display: inline-flex;

        gap: 20px;
        margin-bottom: 20px;
        max-width: 800px;
      }

      .styleChoice {
        padding: 10px;
        border: 1px solid #ccc;
        border-radius: 4px;
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      .stylePreview {
        text-align: center;
        padding: 10px;
        margin-top: 5px;
        min-height: 60px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .radio-label {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      @keyframes breathe {
        0%,
        100% {
          transform: scale(1);
        }
        50% {
          transform: scale(0.95);
        }
      }

      @keyframes neoGlow {
        0%,
        100% {
          filter: drop-shadow(0 4px 20px rgba(0, 212, 255, 0.4))
            drop-shadow(0 0 40px rgba(255, 0, 255, 0.2));
          transform: scale(1);
        }
        25% {
          filter: drop-shadow(0 4px 25px rgba(255, 0, 255, 0.5))
            drop-shadow(0 0 50px rgba(0, 255, 136, 0.3));
          transform: scale(1.02);
        }
        50% {
          filter: drop-shadow(0 4px 30px rgba(0, 255, 136, 0.6))
            drop-shadow(0 0 60px rgba(255, 170, 0, 0.4));
          transform: scale(1.01);
        }
        75% {
          filter: drop-shadow(0 4px 25px rgba(255, 170, 0, 0.5))
            drop-shadow(0 0 50px rgba(255, 0, 153, 0.3));
          transform: scale(1.02);
        }
      }
    </style>
  </head>
  <body>
    <div id="displayText">Loading...</div>

    <div id="inputContainer" style="display: none">
      <textarea id="textInput" placeholder="Enter text here"></textarea>
      <div id="styleOptions"></div>
      <button onclick="updateText()">Set Text</button>
    </div>

    <script>
      // First, define the styles
      const STYLE_PRESETS = {
        default: {
          name: "Default",
          styles: {
            fontFamily:
              'Impact, Haettenschweiler, "Arial Narrow Bold", sans-serif',
            backgroundColor: "#000000",
            color: "#ffffff",
            border: "1px solid #666",
          },
        },
        retro: {
          name: "Retro",
          styles: {
            fontFamily: "Courier New, monospace",
            backgroundColor: "#f4f1c1",
            color: "#000000",
            border: "2px solid #8b8b83",
          },
        },
        modern: {
          name: "Modern",
          styles: {
            fontFamily: "Arial, sans-serif",
            backgroundColor: "#ffffff",
            color: "#333333",
            border: "1px solid #e0e0e0",
            borderRadius: "8px",
          },
        },
        playful: {
          name: "Playful",
          styles: {
            fontFamily: "Comic Sans MS, cursive",
            backgroundColor: "#fff0f5",
            color: "#ff1493",
            border: "3px dashed #ff69b4",
            borderRadius: "12px",
          },
        },
        neon: {
          name: "Neon",
          styles: {
            fontFamily: "Orbitron, sans-serif",
            backgroundColor: "#000000",
            color: "#00ff00",
            border: "2px solid #00ff00",
            textShadow: "0 0 0.05em #00ff00, 0 0 0.1em #00ff00",
            borderRadius: "4px",
          },
        },
        vintage: {
          name: "Vintage",
          styles: {
            fontFamily: "Georgia, serif",
            backgroundColor: "#f4e4bc",
            color: "#8b4513",
            border: "3px double #8b4513",
            textShadow: "0.05em 0.05em 0 #d2b48c",
          },
        },
        cyberpunk: {
          name: "Cyberpunk",
          styles: {
            fontFamily: '"Press Start 2P", cursive',
            backgroundColor: "#ff00ff",
            color: "#00ffff",
            border: "3px solid #00ffff",
            textShadow: " -0.01em -0.01em 0 #ffff00",
            borderRadius: "0",
          },
        },
        hox: {
          name: "Hox",
          styles: {
            fontFamily: "HeavyData Nerd Font, sans-serif",
            backgroundColor: "#1a1c34",
            color: "#f1f1f1",
            border: "1px solid #666",
          },
        },
        ankh: {
          name: "Ankh",
          styles: {
            fontFamily: "HeavyData Nerd Font, sans-serif",
            backgroundColor: "#1a1c34",
            color: "#f1f1f1",
            border: "1px solid #666",
          },
        },
        neo2030: {
          name: "Neo 2030",
          styles: {
            fontFamily:
              '"SF Pro Display", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
            backgroundColor: "#1a1c34",
            color: "#00d4ff",
            textShadow:
              "0 0 30px rgba(0, 212, 255, 0.8), 0 0 60px rgba(255, 0, 255, 0.4), 0 0 90px rgba(0, 255, 136, 0.3)",
            filter: "drop-shadow(0 4px 20px rgba(0, 212, 255, 0.6))",
            border: "2px solid rgba(0, 212, 255, 0.4)",
            borderRadius: "8px",
            margin: "100px",
          },
        },
      };

      // Then initialize everything
      const params = new URLSearchParams(window.location.search);
      const encodedText = params.get("text");
      const isEditMode = params.get("mode") === "edit";
      const urlStyle = params.get("style") || "default";

      const displayText = document.getElementById("displayText");
      const inputContainer = document.getElementById("inputContainer");

      // Show input container in edit mode or when no text
      if (!encodedText || isEditMode) {
        displayText.style.display = "none";
        inputContainer.style.display = "flex";
        generateStylePreviews();

        // If we have text, populate the input field and select the style
        if (encodedText) {
          try {
            const decodedText = atob(encodedText);
            document.getElementById("textInput").value = decodedText;
            updatePreviews(decodedText);
          } catch (e) {
            console.error("Invalid base64 text");
          }
        }
      } else {
        // Show mode - display the text
        try {
          const decodedText = atob(encodedText);
          displayText.textContent = decodedText;
          displayText.style.display = "block";
          inputContainer.style.display = "none";

          // Apply the style from URL parameter
          applyStyle(displayText, urlStyle);

          // Add an edit button
          const editButton = document.createElement("button");
          editButton.textContent = "X";
          editButton.style.position = "fixed";
          editButton.style.bottom = "20px";
          editButton.style.right = "20px";
          editButton.style.backgroundColor = "transparent";
          editButton.style.border = "1px solid transparent";
          editButton.style.borderRadius = "4px";
          // Set text color to opposite of background color
          const bgColor = STYLE_PRESETS[urlStyle].styles.backgroundColor;
          editButton.style.color =
            bgColor === "#000000" ? "#ffffff" : "#000000";
          editButton.onclick = () => {
            window.location.href = `${window.location.pathname}?text=${encodedText}&style=${urlStyle}&mode=edit`;
          };
          document.body.appendChild(editButton);

          adjustFontSize();
        } catch (e) {
          console.error("Invalid base64 text");
          displayText.textContent = "Error: Invalid text format";
        }
      }

      function updatePreviews(text) {
        const previews = document.querySelectorAll(".stylePreview");
        previews.forEach((preview) => {
          preview.textContent = text || "Preview: Hello World!";
        });
      }

      function generateStylePreviews() {
        const container = document.getElementById("inputContainer");
        const textarea = document.getElementById("textInput");

        // Remove any existing style options
        const existingOptions = document.getElementById("styleOptions");
        if (existingOptions) {
          existingOptions.remove();
        }

        const styleOptions = document.createElement("div");
        styleOptions.id = "styleOptions";

        Object.entries(STYLE_PRESETS).forEach(([key, preset]) => {
          const styleChoice = document.createElement("div");
          styleChoice.className = "styleChoice";

          const labelContainer = document.createElement("div");
          labelContainer.className = "radio-label";

          const radio = document.createElement("input");
          radio.type = "radio";
          radio.id = `${key}Style`;
          radio.name = "style";
          radio.value = key;
          radio.onchange = () => {
            applyStyle(textarea, key); // Apply style to textarea when radio changes
            applyPreset();
            const newText = document.getElementById("textInput").value;
            if (newText.trim() !== "") {
              const encodedText = btoa(newText);
              window.location.href = `${window.location.pathname}?text=${encodedText}&style=${key}&mode=edit`;
            }
          };
          // Set the initial selected style from URL
          if (key === urlStyle) {
            radio.checked = true;
            applyStyle(textarea, key); // Apply style to textarea initially
          }

          const label = document.createElement("label");
          label.htmlFor = `${key}Style`;
          label.textContent = preset.name;

          labelContainer.appendChild(radio);
          labelContainer.appendChild(label);

          const preview = document.createElement("div");
          preview.className = "stylePreview";
          preview.textContent = "Preview: Hello World!";
          Object.assign(preview.style, preset.styles);

          styleChoice.appendChild(labelContainer);
          styleChoice.appendChild(preview);

          styleOptions.appendChild(styleChoice);
        });

        // Insert after textarea
        textarea.after(styleOptions);

        // Add input event listener to textarea
        textarea.addEventListener("input", (e) => {
          updatePreviews(e.target.value);
        });
      }

      // Update applyStyle to use the new STYLE_PRESETS
      function applyStyle(element, preset, isInput = false) {
        const selectedPreset = STYLE_PRESETS[preset] || STYLE_PRESETS.default;

        // Reset all possible style properties first
        element.style.fontFamily = "";
        element.style.backgroundColor = "";
        element.style.color = "";
        element.style.border = "";
        element.style.borderRadius = "";
        element.style.textShadow = "";

        // Then apply the new styles
        Object.assign(element.style, selectedPreset.styles);

        // Handle text animation if specified in preset
        if (selectedPreset.textAnimation && element.id === "displayText") {
          // Wrap text content with animated span
          const currentText = element.textContent;
          element.innerHTML = `<span style="display: inline-block; animation: ${selectedPreset.textAnimation};">${currentText}</span>`;
        } else if (element.id === "displayText") {
          // For other styles, ensure no span wrapper
          const currentText = element.textContent || element.innerHTML;
          element.textContent = currentText;
        }
      }

      // Add styles to the page
      const styleSheet = document.createElement("style");
      styleSheet.textContent = `
          #inputContainer {
              max-width: 1200px;
              margin: 0 auto;
          }

          #inputContainer #styleOptions {
              display: grid;
              grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
              gap: 20px;
              margin-bottom: 20px;
          }

          #inputContainer .styleChoice {
              width: auto !important;
              padding: 15px;
              border: 1px solid #ccc;
              border-radius: 4px;
              display: flex;
              flex-direction: column;
              gap: 10px;
              min-width: 0;
          }

          #inputContainer .stylePreview {
              text-align: center;
              padding: 20px;
              margin-top: 5px;
              min-height: 60px;
              display: flex;
              align-items: center;
              justify-content: center;
              word-break: break-word;
              box-sizing: border-box;
          }

          #inputContainer .radio-label {
              display: flex;
              align-items: center;
              gap: 8px;
          }

          #inputContainer #textInput {
              margin-top: 20px;
              box-sizing: border-box;
          }
      `;
      document.head.appendChild(styleSheet);

      // Initialize on page load
      window.onload = function () {
        generateStylePreviews();
        // ... rest of your existing onload code ...
      };

      function applyPreset() {
        const preset = document.querySelector(
          'input[name="style"]:checked'
        ).value;
        applyStyle(document.getElementById("textInput"), preset, true);
        applyStyle(document.getElementById("stylePreview"), preset, true);
      }

      function updateText() {
        const newText = document.getElementById("textInput").value;
        const selectedStyle = document.querySelector(
          'input[name="style"]:checked'
        ).value;

        if (newText.trim() !== "") {
          const encodedText = btoa(newText);
          // Redirect to show mode with the new text
          window.location.href = `${window.location.pathname}?text=${encodedText}&style=${selectedStyle}`;
        }
      }

      function adjustFontSize() {
        const container = displayText.parentNode;
        const containerWidth = container.clientWidth;
        const containerHeight = container.clientHeight;
        const originalText = displayText.textContent.trim();
        const hasAnimatedSpan = displayText.querySelector(
          'span[style*="animation"]'
        );
        let fontSize = 10000; // Start with a large font size

        // First, disable any CSS word breaking to ensure we control it
        displayText.style.overflowWrap = "normal";
        displayText.style.wordWrap = "normal";
        displayText.style.whiteSpace = "pre-line"; // Respect \n but wrap at container edge

        displayText.style.fontSize = fontSize + "px";

        // Set text content appropriately based on whether we have animation
        if (hasAnimatedSpan) {
          const animationStyle = hasAnimatedSpan.style.animation;
          displayText.innerHTML = `<span style="display: inline-block; animation: ${animationStyle};">${originalText}</span>`;
        } else {
          displayText.textContent = originalText;
        }

        // First pass: try to fit as single line
        while (
          (displayText.scrollWidth > containerWidth ||
            displayText.scrollHeight > containerHeight) &&
          fontSize > 10
        ) {
          fontSize -= 5;
          displayText.style.fontSize = fontSize + "px";
        }

        // If single line doesn't work well, try strategic line breaks
        if (fontSize < 100) {
          // If we had to shrink the font a lot
          const words = originalText.split(" ");
          if (words.length > 1) {
            let bestText = originalText;
            let bestFontSize = fontSize;

            // Try breaking roughly in the middle
            const midPoint = Math.floor(words.length / 2);
            const variations = [midPoint - 1, midPoint, midPoint + 1].filter(
              (i) => i > 0 && i < words.length
            );

            for (const breakPoint of variations) {
              const testText =
                words.slice(0, breakPoint).join(" ") +
                "\n" +
                words.slice(breakPoint).join(" ");
              displayText.textContent = testText;

              let testFontSize = 10000;
              displayText.style.fontSize = testFontSize + "px";

              // Find max font size for this layout
              while (
                (displayText.scrollWidth > containerWidth ||
                  displayText.scrollHeight > containerHeight) &&
                testFontSize > 10
              ) {
                testFontSize -= 5;
                displayText.style.fontSize = testFontSize + "px";
              }

              if (testFontSize > bestFontSize) {
                bestText = testText;
                bestFontSize = testFontSize;
              }
            }

            displayText.textContent = bestText;
            displayText.style.fontSize = bestFontSize + "px";
          }
        }

        // Ensure vertical centering after sizing (only in display mode)
        if (displayText.style.display !== "none") {
          displayText.style.display = "flex";
          displayText.style.alignItems = "center";
          displayText.style.justifyContent = "center";
        }
      }

      // Adjust font size on window resize
      window.addEventListener("resize", adjustFontSize);
    </script>
  </body>
</html>
